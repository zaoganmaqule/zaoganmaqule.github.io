<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于One_gadget</title>
    <url>/2024/04/19/%E5%85%B3%E4%BA%8Eone-gadget/</url>
    <content><![CDATA[<h2 id="题目描述存在用户输入获取函数指针，并通过函数指针调用相应的函数。需要注意的是，这种通过用户输入来获取函数指针并调用函数的做法极其危险。"><a href="#题目描述存在用户输入获取函数指针，并通过函数指针调用相应的函数。需要注意的是，这种通过用户输入来获取函数指针并调用函数的做法极其危险。" class="headerlink" title="题目描述存在用户输入获取函数指针，并通过函数指针调用相应的函数。需要注意的是，这种通过用户输入来获取函数指针并调用函数的做法极其危险。"></a>题目描述存在用户输入获取函数指针，并通过函数指针调用相应的函数。需要注意的是，这种通过用户输入来获取函数指针并调用函数的做法极其危险。</h2><p>one_gadget是libc中存在的一些执行execve(“bin&#x2F;sh”,NULL,NULL)的片段，当可以泄露libc地址，并且可以知道libc版本的时候，可以使用此方法来快速控制指令寄存器开始shell。相当于system(“&#x2F;bin&#x2F;sh”)，这种方式更方便，不用控制RDI，RSI，RDX等寄存器。</p>
<p>安装方式</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token parameter variable">-y</span> <span class="token function">install</span> ruby
<span class="token function">sudo</span> gem <span class="token function">install</span> one_gadget<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用方法</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">one_gadget libc.so.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>one_gadget并不总是可以获取shell，它首先要满足一些条件才能执行成功。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>Binary</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Python3如何实现base64编码解码</title>
    <url>/2024/04/19/%E5%85%B3%E4%BA%8Epython3%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0base64%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2024/04/19/B2j1kgEqVI8FYbu.png" alt="image-20240419114231543.png"></p>
<p>AttributeError: ‘bytes’ object has no attribute ‘encode’是：“字节”对象没有属性的编码的意思。</p>
<p>很明显，是编码格式的问题。</p>
<p>使用.encode(“base64”)在python3中会报错。b64encode函数的参数为byte类型，而python3中字符都是unicode编码，所以在进行base64编码之前必须先转码。base64生成的编码都是ascii字符。</p>
<p>解一般的pwn题目的方式。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">payload_ <span class="token operator">=</span> <span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>源码</p>
<p><img src="https://s2.loli.net/2024/04/19/SPQ7A8uUGEICTZe.png" alt="image-20240419120225364.png"></p>
<p>执行结果</p>
<p><img src="https://s2.loli.net/2024/04/19/pUEQFSbCgWKDiLo.png" alt="image-20240419120244744.png"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Binary</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Ret2reg的理解</title>
    <url>/2024/04/20/%E6%B5%85%E8%B0%88Ret2reg%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>1，查看栈溢出返回时哪个寄存器指向缓冲区空间。</p>
<p>2，查看对应的call寄存器或jmp寄存器指令，将IP设置为该指令地址。</p>
<p>3，将寄存器所指向的空间上注入shellcode（该空间是可执行的，通常是栈上）</p>
<p>4，一般解题该漏洞的特点是存在危险函数strcpy的字符串拷贝函数</p>
<h2 id="解题一般步骤"><a href="#解题一般步骤" class="headerlink" title="解题一般步骤"></a>解题一般步骤</h2><p>1，检查保护存在RWX segments</p>
<p>2，使用gdb调试程序，看看那些寄存器是指向缓冲区的</p>
<p>3，在利用</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ROPgadget <span class="token parameter variable">--binary</span> vuln <span class="token parameter variable">--only</span> <span class="token string">"call"</span>
ROPgadget <span class="token parameter variable">--binary</span> vuln <span class="token parameter variable">--only</span> <span class="token string">"jmp"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>4,栈布局</p>
<p><img src="https://s2.loli.net/2024/04/20/JhgWtfbFX9EemaO.png" alt=".PNG"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>Binary</tag>
        <tag>ROP</tag>
      </tags>
  </entry>
  <entry>
    <title>实验室看到的一个问题</title>
    <url>/2024/04/21/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2024/04/21/wLnhEU6yuDTf3le.png" alt="1.PNG"><br>可以先思考思考为啥？学弟问的问题，明显就是没有做好交互，但为啥会一起发送呢？</p>
<p>我去网上找了找相关知识，<br><img src="https://s2.loli.net/2024/04/21/MFfi7To1BIbtOVg.png" alt="B12262FE6DF289C7494B2771A7C12E24.png"></p>
<p>突然来了点思路，但还是不确定，不如自己去写过c程序试试呗。<br><img src="https://s2.loli.net/2024/04/21/QPwT1Lpy5mMtZSx.png" alt="2.PNG"></p>
<p>源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nbytes<span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+]Please inputs the length of your name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"[+]What's u name?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span>nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结合scanf遇到空格符会停下，我构造payload</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">payload <span class="token operator">=</span> <span class="token string">b'-1'</span> <span class="token operator">+</span> <span class="token string">b'\x0a'</span> <span class="token operator">+</span> <span class="token string">b'aaaaaaaaaaaaaaaaaaaa'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p><img src="https://s2.loli.net/2024/04/21/wPSvWbhEo23Nrkd.png" alt="3.PNG"></p>
<p>可以看到换行符后面的内容也读入进去了。</p>
<p>现在回来看看问题。猜测会不会是scanf和read的缓冲区不一样呢？<br><img src="https://s2.loli.net/2024/04/21/ECs57NwIuekXQ2D.png" alt="4.PNG"></p>
<p>问了问chatgpt，得到了准确的答案。我也学习到了，io流和标准输入流的缓冲区不一样。</p>
<p>下次还是要做好交互吧！</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>Binary</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Ret2dlresolve</title>
    <url>/2024/04/20/%E6%B5%85%E8%B0%88ret2dlresolve/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在linux中，程序使用_dl_runtime_resolve(link_map_obj,reloc_offset)来进行动态链接的函数进行重定位。那么如果我们可以控制相应的参数及其对应地址的内容是不是就可以直接控制解析的函数了。具体就是利用动态链接器在解析符号地址时所使用的重定位表项、动态符号表、动态符号串都是从目标文件中的动态节.dynamic索引得到的。所以如果我们能够修改其中的某些内容使得最后动态链接器解析的符号是我们想要解析的符号，那就攻击成功。</p>
<h2 id="基础知识-延迟绑定"><a href="#基础知识-延迟绑定" class="headerlink" title="基础知识-延迟绑定"></a>基础知识-延迟绑定</h2><p>思考思考，在linux中一个函数是如何正常运行的呢？</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>ROP</tag>
        <tag>ret2dlresolve</tag>
      </tags>
  </entry>
</search>
